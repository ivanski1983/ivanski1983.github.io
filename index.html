<!doctype html>
<html>
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ZXing Scanner (Phone Optimized)</title>
<script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0"></script>
<style>
  body{font-family:system-ui,sans-serif;margin:16px}
  video{width:100%;max-width:520px;background:#000;border-radius:12px}
  .row{display:flex;gap:8px;margin:12px 0;flex-wrap:wrap}
  button{padding:10px 14px;border:1px solid #ddd;border-radius:10px}
  #res{font-weight:700;margin-top:8px}
  #err{white-space:pre-wrap;color:#b00020;margin-top:8px}
  #hint{color:#444;font-size:14px}
</style>
</head>
<body>
<h1>Barcode Scanner</h1>
<p id="hint">Tip: fill the frame ~60–80% with the barcode, good light, reduce glare.</p>

<video id="v" playsinline muted></video>

<div class="row">
  <button id="start">Start</button>
  <button id="stop" disabled>Stop</button>
  <button id="flash" disabled>Flash</button>
</div>

<div id="res">Result: <span id="text">—</span></div>
<pre id="err"></pre>

<script>
const v = document.getElementById('v');
const out = document.getElementById('text');
const err = document.getElementById('err');
const btnStart = document.getElementById('start');
const btnStop  = document.getElementById('stop');
const btnFlash = document.getElementById('flash');

let reader, currentStream, torchOn = false;

// Hints: restrict formats + try harder/inverted
const hints = new Map();
hints.set(ZXing.DecodeHintType.POSSIBLE_FORMATS, [
  ZXing.BarcodeFormat.EAN_13,
  ZXing.BarcodeFormat.EAN_8,
  ZXing.BarcodeFormat.UPC_A,
  ZXing.BarcodeFormat.UPC_E,
  ZXing.BarcodeFormat.CODE_128,
  ZXing.BarcodeFormat.CODE_39,
  ZXing.BarcodeFormat.ITF,
  ZXing.BarcodeFormat.QR_CODE
]);
hints.set(ZXing.DecodeHintType.TRY_HARDER, true);
hints.set(ZXing.DecodeHintType.ASSUME_GS1, true); // optional for retail barcodes
hints.set(ZXing.DecodeHintType.ALSO_INVERTED, true); // aka TRY_INVERTED

// Reduce CPU by spacing scans a bit (ms). 150–300 is good on phones.
const SCAN_INTERVAL = 200;

reader = new ZXing.BrowserMultiFormatReader(hints, SCAN_INTERVAL);

function showErr(e,prefix=''){
  const msg = (e && e.message) ? e.message : String(e || '');
  if (prefix) err.textContent = prefix + '\n' + msg;
  else err.textContent = msg;
  console.error(prefix || 'Error', e);
}

// Try toggling torch if supported
async function setTorch(enable){
  try {
    if (!currentStream) return;
    const track = currentStream.getVideoTracks()[0];
    const caps = track.getCapabilities?.();
    if (!caps || !caps.torch) return; // not supported
    await track.applyConstraints({ advanced: [{ torch: enable }] });
    torchOn = enable;
    btnFlash.textContent = enable ? 'Flash Off' : 'Flash On';
  } catch(e){ /* ignore torch errors */ }
}

btnFlash.addEventListener('click', ()=> setTorch(!torchOn));

async function start() {
  err.textContent = ''; out.textContent = '—';
  btnStart.disabled = true; btnStop.disabled = false;
  btnFlash.disabled = true; torchOn = false;

  // 1) Start with facingMode environment
  try {
    await reader.decodeFromConstraints(
      { video: { facingMode: { ideal: 'environment' }, width:{ideal:1280}, height:{ideal:720} }, audio:false },
      v,
      (result, zerr) => {
        // ZXing emits lots of null/err while searching; we only act on result.
        if (result) {
          out.textContent = result.getText();
          // Example: stop after first scan
          // stop();
          // Send to your app: window.location.href = 'godot://scan/'+encodeURIComponent(result.getText());
        }
      }
    );
    // IMPORTANT for iOS: ensure play() happens
    try { await v.play(); } catch {}
  } catch(e1) {
    showErr(e1, 'FacingMode failed; trying deviceId…');
    try {
      // 2) Unlock labels (iOS) & pick rear camera
      const tmp = await navigator.mediaDevices.getUserMedia({ video:true, audio:false });
      tmp.getTracks().forEach(t=>t.stop());
      const devs = await navigator.mediaDevices.enumerateDevices();
      const cams = devs.filter(d=>d.kind==='videoinput');
      if (!cams.length) throw new Error('No cameras found.');
      const rear = cams.find(d=>/back|rear|environment/i.test(d.label)) || cams[cams.length-1];

      await reader.decodeFromVideoDevice(rear.deviceId, v, (result, zerr)=>{
        if (result) out.textContent = result.getText();
      });
      try { await v.play(); } catch {}
    } catch(e2){
      showErr(e2, 'Could not start camera.\nCheck HTTPS, permissions, and close other camera apps.');
      btnStart.disabled = false; btnStop.disabled = true;
      return;
    }
  }

  // Keep a handle to the stream for torch/cleanup
  currentStream = v.srcObject || (v._zxingVideoSrcObject || null) || (reader.stream || null);
  // Enable torch button if supported
  try {
    const track = (currentStream && currentStream.getVideoTracks()[0]);
    const caps = track?.getCapabilities?.();
    if (caps && caps.torch) btnFlash.disabled = false;
  } catch {}

  // Autofocus hint (some browsers honor this)
  try {
    const track = currentStream?.getVideoTracks?.()[0];
    await track?.applyConstraints?.({ advanced: [{ focusMode: 'continuous' }] });
  } catch {}
}

function stop(){
  try { reader.reset(); } catch {}
  if (currentStream) {
    currentStream.getTracks().forEach(t=>t.stop());
    currentStream = null;
  }
  v.srcObject = null;
  btnStart.disabled = false; btnStop.disabled = true; btnFlash.disabled = true;
  if (torchOn) setTorch(false);
}

btnStart.addEventListener('click', start);
btnStop .addEventListener('click', stop);
</script>
</body>
</html>

