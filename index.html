<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Back-Camera Barcode Scanner</title>
  <script src="https://cdn.jsdelivr.net/npm/@zxing/library@0.20.0"></script>
  <style>
    body { font-family: system-ui, sans-serif; margin: 16px; }
    video { width: 100%; max-width: 520px; background:#000; border-radius: 12px; }
    .row { display:flex; gap:8px; margin:12px 0; }
    button { padding:10px 14px; border-radius: 10px; border:1px solid #ddd; }
    #result { font-weight: 700; margin-top: 8px; }
    #error { color:#b00020; white-space:pre-wrap; margin-top:8px; }
    #hint { color:#444; font-size:14px; line-height:1.2; }
  </style>
</head>
<body>
  <h1>Barcode Scanner (Forces Back Camera)</h1>
  <p id="hint">Tip: Use this over <b>HTTPS</b>. On iPhone, open in Safari (Settings → Safari → Camera → Allow).</p>

  <video id="preview" playsinline muted autoplay></video>

  <div class="row">
    <button id="start">Start</button>
    <button id="stop" disabled>Stop</button>
  </div>

  <div id="result">Result: <span id="text">—</span></div>
  <div id="error"></div>

  <script>
    const video = document.getElementById('preview');
    const btnStart = document.getElementById('start');
    const btnStop  = document.getElementById('stop');
    const outText  = document.getElementById('text');
    const outErr   = document.getElementById('error');

    // Keep one global reader
    const reader = new ZXing.BrowserMultiFormatReader();
    let activeDeviceId = null;

    function logErr(e, prefix="") {
      console.error(prefix, e);
      outErr.textContent = (prefix ? prefix + "\n" : "") + (e && e.message ? e.message : String(e));
    }

    async function getRearDeviceId() {
      // After permission, device labels become available on iOS.
      const devices = await navigator.mediaDevices.enumerateDevices();
      const cams = devices.filter(d => d.kind === 'videoinput');
      if (!cams.length) return null;

      // Look for labels hinting back/rear/environment
      const rear = cams.find(d => /back|rear|environment/i.test(d.label));
      if (rear) return rear.deviceId;

      // Heuristic: on many phones, the last videoinput is the rear camera
      return cams[cams.length - 1].deviceId;
    }

    async function unlockLabelsIfNeeded() {
      // If labels are empty on iOS, open a throwaway stream to unlock them
      const devices = await navigator.mediaDevices.enumerateDevices();
      const noLabels = devices.some(d => d.kind === 'videoinput' && !d.label);
      if (!noLabels) return;

      const tmp = await navigator.mediaDevices.getUserMedia({ video: true, audio: false });
      tmp.getTracks().forEach(t => t.stop());
    }

    async function startWithFacingMode() {
      // Preferred: ask for the environment camera by constraint (simple path)
      await reader.decodeFromConstraints(
        { video: { facingMode: { ideal: "environment" }, width: { ideal: 1280 }, height: { ideal: 720 } }, audio: false },
        video,
        (result, err) => {
          if (result) outText.textContent = result.getText();
        }
      );
    }

    async function startWithDeviceId(deviceId) {
      await reader.decodeFromVideoDevice(
        deviceId,
        video,



